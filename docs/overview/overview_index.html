<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Quick Introduction · ZIO Profiling</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="ZIO Profiling is a collection of different profilers for better understanding the runtime behavior of ZIO programs."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Quick Introduction · ZIO Profiling"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-profiling/"/><meta property="og:description" content="ZIO Profiling is a collection of different profilers for better understanding the runtime behavior of ZIO programs."/><meta property="og:image" content="https://zio.github.io/zio-profiling/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://zio.github.io/zio-profiling/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/zio-profiling/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-profiling/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-profiling/css/main.css"/><script src="/zio-profiling/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-profiling/"><img class="logo" src="/zio-profiling/img/navbar_brand2x.png" alt="ZIO Profiling"/><h2 class="headerTitleWithLogo">ZIO Profiling</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/zio-profiling/docs/overview/overview_index" target="_self">Overview</a></li><li class=""><a href="/zio-profiling/docs/resources/resources_index" target="_self">Resources</a></li><li class=""><a href="/zio-profiling/docs/about/about_index" target="_self">About</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Overview</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Overview</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/zio-profiling/docs/overview/overview_index">Quick Introduction</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Quick Introduction</h1></header><article><div><span><p>ZIO Profiling is a collection of different profilers for better understanding the runtime behavior of ZIO programs.</p>
<p>Normal cpu profilers cannot really be used to profile code using an effect system.
Profilers operating on a thread level will only see that threads are spending time in the evaluation loop of the
effect system, producing profiles that are not useful for application developers.</p>
<p>Instead, profiling a program written using an effect system requires a profiler that is aware of the effect system
and can report where the effects were constructed / which user code the effect system is spending time on.
ZIO profiling aims to be that library for the ZIO effect system.</p>
<p>The library focuses exclusively on cpu profiling. For heap profiling please consider using other tools such as async-profiler
or VisualVM.</p>
<h2><a class="anchor" aria-hidden="true" id="installation"></a><a href="#installation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>ZIO Profiling requires you to add both the main library and optionally the compiler plugin to your build.sbt:</p>
<pre><code class="hljs css language-scala">libraryDependencies += <span class="hljs-string">"dev.zio"</span> %% <span class="hljs-string">"zio-profiling"</span> % zioProfilingVersion
libraryDependencies += compilerPlugin(<span class="hljs-string">"dev.zio"</span> %% <span class="hljs-string">"zio-profiling-tagging-plugin"</span> % zioProfilingVersion)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="profiling-an-application-and-displaying-a-flamegraph"></a><a href="#profiling-an-application-and-displaying-a-flamegraph" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Profiling an application and displaying a flamegraph</h2>
<p>For this example we are going to use the sampling profiler to measure the cpu time used by parts of a zio program.
All needed definitions can be imported using:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.profiling.sampling._
</code></pre>
<p>The program we want to instrument simulates performing a short and then a long computation concurrently:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> fast = <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">400</span>))

<span class="hljs-keyword">val</span> slow = <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">600</span>))

<span class="hljs-keyword">val</span> program = fast &lt;&amp;&gt; slow
</code></pre>
<p>In order to profile the program, we wrap it with the <code>profile</code> method of the tracing profiler. Once the effect has completed
this will yield the profiling result. We can either manipulate the result in Scala or render it in a number of standard
formats. In this case we are going to write it out in a format supported by <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a>, so we
can visualize it as a flamegraph.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">TracingProfiler</span>
  .profile(program)
  .flatMap(_.stackCollapseToFile(<span class="hljs-string">"profile.folded"</span>))
</code></pre>
<p>The resulting file can be converted to a svg using the flamegraph.pl script (<a href="../../img/example_tracing_profile.svg">preview</a>):</p>
<pre><code class="hljs css language-bash">flamegraph.pl ./examples/profile.folded &gt; profile.svg
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="causal-profiling"></a><a href="#causal-profiling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Causal Profiling</h2>
<p>ZIO Profiling includes experimental support for causal profiling inspired by <a href="https://github.com/plasma-umass/coz">coz</a>.</p>
<p>Usage is similar to the tracing profiler, but instead of displaying the time spent running the program it will give recommendations
which parts of the program to focus on during performance tuning for biggest effect. It achieves this by iteratively artificially speeding
up parts of the program (by slowing down all parts running concurrently) and measuring the effect on overall runtime.</p>
<p>Check out the paper linked in the coz repository for more details about the idea.</p>
<p>We can bring the causal profiler into scope with the following import:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.profiling.causal._
</code></pre>
<p>This time we are using a slightly more complicated example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> fast = <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">40</span>))

<span class="hljs-keyword">val</span> slow1 = <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">20</span>))

<span class="hljs-keyword">val</span> slow2 = <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">60</span>))

<span class="hljs-keyword">val</span> slow = slow1 &lt;&amp;&gt; slow2

<span class="hljs-keyword">val</span> program = (fast &lt;&amp;&gt; slow) *&gt;
  <span class="hljs-type">CausalProfiler</span>.progressPoint(<span class="hljs-string">"iteration done"</span>)

<span class="hljs-type">CausalProfiler</span>(iterations = <span class="hljs-number">100</span>)
  .profile(program.forever)
  .flatMap(_.renderToFile(<span class="hljs-string">"profile.coz"</span>))
</code></pre>
<p>We also need to weave the <code>progressPoint</code> effect into our program. It will be used by the causal profiler to measure progress
of the overall program.</p>
<p>Finally, we can run the program using the causal profiler (notice the use of <code>program.forever</code> -- the profiler will automatically interrupt the program, until then it has to keep running)
and save the result to a file.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">CausalProfiler</span>(iterations = <span class="hljs-number">100</span>)
  .profile(prog.forever)
  .flatMap(_.renderToFile(<span class="hljs-string">"profile.coz"</span>))
</code></pre>
<p>The file can be viewed using the <a href="https://plasma-umass.org/coz/">Coz Visualizer</a> (<a href="../../img/example_causal_profile.png">preview</a>).
As you can see, the profiler correctly tells you that you can get up to a 33% speedup by optimizing the <code>slow2</code> effect,
but it's impossible to get a speedup any other way.</p>
<h2><a class="anchor" aria-hidden="true" id="compiler-plugin"></a><a href="#compiler-plugin" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compiler Plugin</h2>
<p>In order to produce actionable output, a profiler not only needs to know which line of code is currently running, but also how that location was reached.</p>
<p>Most profilers rely on the function call hierarchy to determine this information, but the call stack is not really useful for programs using functional effect systems. The reason for this is that the normal function calls are only used to build up the program as a datastructure -- not execute it.</p>
<hr>
<p>It's possible to restore the proper callstack while the effects are actually getting executed (this is the approach taken by the zio.Trace machinery), but that is not the approach taken by ZIO Profiling.</p>
<p>Instead, zio-profiling tracks the current 'callstack' of your program using FiberRefs. For this approach to work every effect should be manually annotated using <code>zio.profiling.CostCenter.withChildCostCenter</code>, which will result in a hierarchy of effect tags at runtime.</p>
<p>As this requires modification of large parts of user programs and is bad UX, zio-profiling ships with a compiler plugin (zio-profiling-tagging-plugin) that automates this. Every <code>def</code> or <code>val</code> that returns a zio effect will be rewritten to be properly tagged. Consider this example for the rewrite that happens:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> testEffect = <span class="hljs-type">ZIO</span>.unit

<span class="hljs-comment">// gets rewritten to</span>

<span class="hljs-keyword">val</span> testEffect = <span class="hljs-type">CostCenter</span>.withChildCostCenter(<span class="hljs-string">"foo.Foo.testEffect(Foo.scala:12)"</span>)(<span class="hljs-type">ZIO</span>.unit)
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#installation">Installation</a></li><li><a href="#profiling-an-application-and-displaying-a-flamegraph">Profiling an application and displaying a flamegraph</a></li><li><a href="#causal-profiling">Causal Profiling</a></li><li><a href="#compiler-plugin">Compiler Plugin</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/zio-profiling/" class="nav-home"><img src="/zio-profiling/img/sidebar_brand2x.png" alt="ZIO Profiling"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-profiling" data-icon="octicon-star" data-count-href="/zio/zio-profiling/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-profiling//img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="/zio-profiling/api/zio/profiling/">Scaladoc of zio-profiling</a></div></section><section class="copyright">Copyright © 2022 ZIO Maintainers</section></footer></div></body></html>